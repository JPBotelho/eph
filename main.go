package main

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	io_prometheus_client "github.com/prometheus/client_model/go"
	"github.com/prometheus/common/expfmt"
	"github.com/prometheus/prometheus/model/labels"
	"github.com/prometheus/prometheus/promql"
	"github.com/prometheus/prometheus/util/teststorage"
)

func main() {
	tstart := time.Now()
	// Create ephemeral in-memory storage
	ts, err := teststorage.NewWithError()
	if err != nil {
		log.Fatal("Failed to create storage")
	}

	// Add some sample data: 0, 5, 10 for http_requests_total
	app := ts.Appender(context.Background())

	/*f, err := os.Open("data")
	if err != nil {
		log.Fatalf("Error opening metrics file: %v", err)
	}
	defer f.Close()
	*/ //_, _ := io.ReadAll(f)
	//fmt.Print(string(b))
	str := `# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime. Sourced from /gc/cycles/automatic:gc-cycles.
# TYPE go_gc_cycles_automatic_gc_cycles_total counter
go_gc_cycles_automatic_gc_cycles_total 209 1754154517000
`
	reader := strings.NewReader(str)

	// Parse metrics file
	var parser expfmt.TextParser
	metricFamilies, err := parser.TextToMetricFamilies(reader)
	fmt.Print(metricFamilies)

	if err != nil {
		log.Fatalf("Error parsing metrics: %v", err)
	}

	// Iterate over metric families
	for name, mf := range metricFamilies {
		fmt.Printf("\nIterating over metric family %s with name %s \n", mf, name)
		for _, m := range mf.Metric {
			fmt.Printf("\nIterating over metric %s\n", m)
			var tsMillis int64
			if m.TimestampMs != nil {

				tsMillis = *m.TimestampMs
			} else {
				// If no explicit timestamp, use now
				fmt.Println("Setting our own timestamp")
				tsMillis = time.Now().UnixMilli()
			}

			// Convert labels to Prometheus internal type
			lbls := labels.NewBuilder(labels.EmptyLabels()).
				Set("__name__", name)

			for _, lp := range m.Label {
				lbls.Set(lp.GetName(), lp.GetValue())
			}

			lset := lbls.Labels()

			// Handle metric types
			switch mf.GetType() {
			case io_prometheus_client.MetricType_COUNTER:
				fmt.Printf("\nAppending counter with ts %d and value %f\n", tsMillis, m.GetCounter().GetValue())
				_, err = app.Append(0, lset, tsMillis, m.GetCounter().GetValue())
			case io_prometheus_client.MetricType_GAUGE:
				_, err = app.Append(0, lset, tsMillis, m.GetGauge().GetValue())
			case io_prometheus_client.MetricType_UNTYPED:
				_, err = app.Append(0, lset, tsMillis, m.GetUntyped().GetValue())
			case io_prometheus_client.MetricType_SUMMARY:
				// Summaries have multiple values; you’d store sum/count separately if you want
				_, err = app.Append(0, lset, tsMillis, m.GetSummary().GetSampleSum())
			case io_prometheus_client.MetricType_HISTOGRAM:
				// Histograms have buckets; you’d store sum/count/buckets separately if you want
				_, err = app.Append(0, lset, tsMillis, m.GetHistogram().GetSampleSum())
			}

			if err != nil {
				log.Printf("Append error for %s: %v", name, err)
			}
		}
	}

	if err := app.Commit(); err != nil {
		log.Fatal(err)
	}

	// Create PromQL engine
	engine := promql.NewEngine(promql.EngineOpts{
		MaxSamples:    10000,
		Timeout:       5 * time.Second,
		LookbackDelta: 5 * time.Minute,
	})

	queryStr := `go_gc_cycles_automatic_gc_cycles_total`
	sampleTime := time.UnixMilli(1754154517000)
	rangeQry, err := engine.NewInstantQuery(
		context.Background(),
		ts,
		nil,
		queryStr,
		sampleTime,
	)
	if err != nil {
		log.Fatalf("Range query creation error: %v", err)
	}

	res := rangeQry.Exec(context.Background())
	if res.Err != nil {
		log.Fatalf("Range query error: %v", res.Err)
	}

	fmt.Println("\nRange Query result:", res.Value)

	// Clean up
	ts.Close()
	fmt.Printf("\nProgram execution time: %v\n", time.Since(tstart))
}
